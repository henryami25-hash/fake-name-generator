<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fake Name Generator</title>

  <!-- Firebase CDN (compat, mobile safe) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg1:#0b1220; --bg2:#0a2a5a;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text:#eaf2ff; --muted:#a9b9d6;
      --ok:#35d07f; --bad:#ff5b6a;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    body{
      margin:0; min-height:100vh; display:flex; justify-content:center; align-items:center;
      padding:18px; color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(124,58,237,.35), transparent 55%),
        radial-gradient(900px 600px at 85% 15%, rgba(78,161,255,.35), transparent 55%),
        linear-gradient(180deg, var(--bg2), var(--bg1));
    }
    .wrap{width:100%; max-width:520px}
    .card{
      border-radius:22px;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{
      padding:16px 16px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: linear-gradient(90deg, rgba(124,58,237,.25), rgba(78,161,255,.18));
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .title{display:flex; flex-direction:column; gap:2px}
    .title h1{margin:0; font-size:18px; letter-spacing:.2px}
    .title p{margin:0; font-size:12px; color:var(--muted)}
    .pill{
      display:none;
      align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      color:var(--muted); font-size:12px; white-space:nowrap;
    }
    .pill a{color:#9fe7ff; text-decoration:none}
    .pill a:hover{text-decoration:underline}
    .notice{
      display:none;
      padding:12px 14px;
      background: rgba(2,6,23,.55);
      border-bottom:1px solid rgba(255,255,255,.10);
      font-size:13px;
    }
    .notice a{color:#9fe7ff; font-weight:800; text-decoration:none}
    .notice a:hover{text-decoration:underline}

    .content{padding:16px}
    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px}
    select,button{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
      font-size:15px;
    }
    .row{display:flex; gap:10px}
    .row>*{flex:1}
    .btn{
      border:none; cursor:pointer;
      font-weight:900; letter-spacing:.2px;
      background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(78,161,255,.95));
      box-shadow: 0 14px 30px rgba(124,58,237,.20);
    }
    .btn:active{transform:translateY(1px)}
    .btn2{
      cursor:pointer;
      font-weight:700;
      background: rgba(255,255,255,.06);
    }
    .out{
      margin-top:14px;
      padding:18px 14px;
      border-radius:18px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      text-align:center;
      user-select:none;
      cursor:pointer;
      min-height:98px;
      display:flex; align-items:center; justify-content:center;
      font-size:24px; font-weight:900;
    }
    .sub{margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45}
    .status{margin-top:10px; font-size:12px; color:var(--muted)}
    .ok{color:var(--ok)} .bad{color:var(--bad)}

    .toast{
      position:fixed;
      left:50%; transform:translateX(-50%);
      bottom:16px;
      background: rgba(2,6,23,.85);
      border:1px solid rgba(255,255,255,.16);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      display:none;
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      font-size:13px;
    }
  </style>
  <link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#000000">
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="title">
          <h1>Fake Name Generator</h1>
          <p>Stylish ‚Ä¢ Smart Random ‚Ä¢ Tap name to copy</p>
        </div>
        <div class="pill" id="tgPill">
          üì¢ <a id="tgLinkTop" href="#" target="_blank" rel="noopener">Telegram</a>
        </div>
      </div>

      <div class="notice" id="noticeBar"></div>

      <div class="content">
        <label>Country</label>
        <select id="countrySelect"><option value="">Loading...</option></select>

        <div class="row">
          <div>
            <label>Gender</label>
            <select id="genderSelect">
              <option value="male">Male</option>
              <option value="female">Female</option>
            </select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn" id="genBtn">Generate</button>
          </div>
        </div>

        <div class="out" id="nameBox" title="Tap to copy">Loading‚Ä¶</div>

        <div class="row" style="margin-top:10px">
          <button class="btn2" id="resetBtn">Reset (this country+gender)</button>
          <button class="btn2" id="refreshBtn">Refresh data</button>
        </div>

        <div class="status" id="statusLine"></div>

        <div class="sub">
          ‚úÖ Smart Random: ‡¶®‡¶æ‡¶Æ‡¶ó‡ßÅ‡¶≤‡ßã shuffle ‡¶π‡ßü‡ßá random order ‡¶è ‡¶Ü‡¶∏‡ßá, list ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶®‡¶§‡ßÅ‡¶® shuffle ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡ßü‡•§<br>
          üìã ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶ü‡ßç‡¶Ø‡¶æ‡¶™ ‡¶ï‡¶∞‡¶≤‡ßá auto-copy ‡¶π‡¶¨‡ßá‡•§
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
/* ========= Firebase Config ========= */
const firebaseConfig = {
  apiKey: "AIzaSyCZ08SgQo36dVouHYVatQjOPBjR7FBuiTM",
  authDomain: "fake-name-generator-445ef.firebaseapp.com",
  projectId: "fake-name-generator-445ef",
  storageBucket: "fake-name-generator-445ef.appspot.com",
  messagingSenderId: "173185143834",
  appId: "1:173185143834:web:e39cfc5ca34abfc458eda3"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

const $ = (id)=>document.getElementById(id);
// ===== Trick 3: 24-hour version check =====
const VERSION_CHECK_INTERVAL = 24 * 60 * 60 * 1000;

function shouldCheckVersion(){
  const last = Number(localStorage.getItem("last_version_check") || 0);
  return (Date.now() - last) > VERSION_CHECK_INTERVAL;
}

function markVersionChecked(){
  localStorage.setItem("last_version_check", Date.now());
}
function toast(msg){
  const t = $("toast");
  t.textContent = msg;
  t.style.display = "block";
  clearTimeout(window.__toastTimer);
  window.__toastTimer = setTimeout(()=>t.style.display="none", 1600);
}

function setStatus(msg, ok=true){
  const el = $("statusLine");
  el.textContent = msg;
  el.className = "status " + (ok ? "ok" : "bad");
}

function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function hashNames(names){
  const s = names.join("\n");
  let h = 5381;
  for(let i=0;i<s.length;i++){
    h = ((h<<5)+h) + s.charCodeAt(i);
    h = h & 0xFFFFFFFF;
  }
  return String(h);
}

async function copyText(text){
  try{
    await navigator.clipboard.writeText(text);
    return true;
  }catch{
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position="fixed";
    ta.style.opacity="0";
    document.body.appendChild(ta);
    ta.select();
    try{
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    }catch{
      document.body.removeChild(ta);
      return false;
    }
  }
}

/* ========= Local State (Smart Random B) ========= */
function keyCG(country, gender){ return `fng_state_${country}__${gender}`; }

function loadState(country, gender){
  try{
    const raw = localStorage.getItem(keyCG(country, gender));
    return raw ? JSON.parse(raw) : null;
  }catch{ return null; }
}
function saveState(country, gender, st){
  localStorage.setItem(keyCG(country, gender), JSON.stringify(st));
}
function resetState(country, gender){
  localStorage.removeItem(keyCG(country, gender));
}

/* ========= In-Memory Cache (kept) ========= */
const cache = { countries: [], namesByCG: {} };
function cg(country, gender){ return `${country}|${gender}`; }

/* =========================================================
   =============== IndexedDB (Option A Sync) ================
   ========================================================= */
const IDB_DB = "fng_idb";
const IDB_VER = 1;
const STORE_META = "meta";
const STORE_NAMES = "names";
const STORE_COUNTRIES = "countries";

function openIDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(IDB_DB, IDB_VER);

    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE_META)) db.createObjectStore(STORE_META);
      if(!db.objectStoreNames.contains(STORE_NAMES)) db.createObjectStore(STORE_NAMES);
      if(!db.objectStoreNames.contains(STORE_COUNTRIES)) db.createObjectStore(STORE_COUNTRIES);
    };

    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error || new Error("IndexedDB open failed"));
  });
}

async function idbGet(store, key){
  const dbi = await openIDB();
  return new Promise((resolve)=>{
    const tx = dbi.transaction(store, "readonly");
    const req = tx.objectStore(store).get(key);
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> resolve(undefined);
  });
}

async function idbSet(store, key, val){
  const dbi = await openIDB();
  return new Promise((resolve, reject)=>{
    const tx = dbi.transaction(store, "readwrite");
    tx.objectStore(store).put(val, key);
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error || new Error("IndexedDB write failed"));
  });
}

async function idbClearStore(store){
  const dbi = await openIDB();
  return new Promise((resolve, reject)=>{
    const tx = dbi.transaction(store, "readwrite");
    const req = tx.objectStore(store).clear();
    req.onsuccess = ()=> resolve(true);
    req.onerror = ()=> reject(req.error || new Error("IndexedDB clear failed"));
  });
}

async function clearAllLocalData(){
  cache.countries = [];
  cache.namesByCG = {};
  await Promise.all([
    idbClearStore(STORE_META),
    idbClearStore(STORE_NAMES),
    idbClearStore(STORE_COUNTRIES),
  ]);
}

/* ========= Version fetch (1 read) =========
   Create in Firestore:
   meta/app  -> { namesVersion: 1 }
*/
async function fetchServerNamesVersion(){
  try{
    const doc = await db.collection("meta").doc("app").get();
    if(doc.exists){
      const d = doc.data() || {};
      const v = Number(d.namesVersion);
      if(Number.isFinite(v)) return v;
    }
  }catch{}
  return null; // if not configured
}

/* ========= Option A Sync: fetch all "names" docs once ========= */
async function syncAllNamesFromServer(){
  setStatus("Syncing data‚Ä¶ (first time may take a bit)", true);

  const snap = await db.collection("names").get();

  const map = {}; // key: "Country|gender" -> array
  const countrySet = new Set();

  snap.forEach(doc=>{
    const d = doc.data() || {};
    const country = (d.country || "").toString().trim();
    const gender = (d.gender || "").toString().trim();
    if(!country || !gender) return;

    countrySet.add(country);

    const key = `${country}|${gender}`;
    if(!map[key]) map[key] = [];

    if(Array.isArray(d.names)){
      for(const n of d.names){
        const s = String(n || "").trim();
        if(s) map[key].push(s);
      }
    }
  });

  // save names per country+gender
  const keys = Object.keys(map);
  for(const k of keys){
    // normalize unique in local (optional)
    const arr = map[k].map(x=>x.trim()).filter(Boolean);
    await idbSet(STORE_NAMES, k, arr);
  }

  const countries = Array.from(countrySet).sort((a,b)=>a.localeCompare(b));
  await idbSet(STORE_COUNTRIES, "list", countries);

  // set local meta
  await idbSet(STORE_META, "lastSyncAt", Date.now());
  // also store a quick signature, so even without version doc you can see it has data
  await idbSet(STORE_META, "hasData", true);

  cache.countries = countries;
  cache.namesByCG = {}; // reset mem cache after sync

  setStatus(`Sync done ‚úÖ Countries: ${countries.length}`, true);
  return { countriesCount: countries.length, keysCount: keys.length };
}

/* ========= Decide sync =========
   - If meta/app.namesVersion exists:
       Sync only when serverVersion != localVersion
   - If not exists:
       Sync only if no local data OR user pressed refresh
*/
async function syncIfNeeded({ force=false } = {}){
  const localHasData = !!(await idbGet(STORE_META, "hasData"));
  const localVersion = Number(await idbGet(STORE_META, "namesVersion") || 0);

let serverVersion = null;

if (force || shouldCheckVersion()) {
  serverVersion = await fetchServerNamesVersion();
  markVersionChecked();
} // may be null

  // If version doc exists -> sync by version
  if(serverVersion !== null){
    if(force || !localHasData || serverVersion !== localVersion){
      await syncAllNamesFromServer();
      await idbSet(STORE_META, "namesVersion", serverVersion);
    }
    return;
  }

  // If version doc not configured -> only sync first time (or force)
  if(force || !localHasData){
    await syncAllNamesFromServer();
  }else{
    setStatus("Ready ‚úÖ (local cache)", true);
  }
}

/* ========= Load countries from local ========= */
async function loadCountriesLocal(){
  if(cache.countries.length) return cache.countries;
  const countries = (await idbGet(STORE_COUNTRIES, "list")) || [];
  cache.countries = Array.isArray(countries) ? countries : [];
  return cache.countries;
}

/* ========= Load names from local ========= */
async function loadNamesLocal(country, gender){
  const k = cg(country, gender);
  if(cache.namesByCG[k]) return cache.namesByCG[k];

  const names = await idbGet(STORE_NAMES, k);
  const arr = Array.isArray(names) ? names.map(n=>String(n).trim()).filter(Boolean) : [];
  cache.namesByCG[k] = arr;
  return arr;
}

/* ========= Notice Listener (kept as-is) ========= */
function startNoticeListener(){
  db.collection("settings").doc("notice").onSnapshot(doc=>{
    if(!doc.exists) return;
    const d = doc.data() || {};
    const active = !!d.noticeActive;
    const text = (d.noticeText || "").trim();
    const tg = (d.tgLink || "").trim();

    if(tg){
      $("tgPill").style.display = "inline-flex";
      $("tgLinkTop").href = tg;
    }else{
      $("tgPill").style.display = "none";
    }

    if(active && text){
      const bar = $("noticeBar");
      bar.style.display = "block";
      bar.innerHTML = tg
        ? `üì¢ ${escapeHtml(text)} ‚Äî <a href="${tg}" target="_blank" rel="noopener">Join Telegram</a>`
        : `üì¢ ${escapeHtml(text)}`;
    }else{
      $("noticeBar").style.display = "none";
    }
  });
}

/* ========= Generate (uses LOCAL names now) ========= */
async function generate(){
  const country = $("countrySelect").value;
  const gender = $("genderSelect").value;

  if(!country){
    setStatus("Please select a country.", false);
    return;
  }

  $("genBtn").disabled = true;
  try{
    const names = await loadNamesLocal(country, gender);
    if(!names.length){
      $("nameBox").textContent = "No names found";
      setStatus(`No names for ${country} (${gender}). Add from admin.`, false);
      return;
    }

    const h = hashNames(names);
    let st = loadState(country, gender);

    // New state if none or list changed
    if(!st || st.hash !== h || !Array.isArray(st.order) || st.total !== names.length){
      const order = Array.from({length:names.length}, (_,i)=>i);
      shuffle(order);
      st = { order, pos: 0, hash: h, total: names.length };
      saveState(country, gender, st);
    }

    // If cycle finished, reshuffle and SAVE immediately
    if(st.pos >= st.order.length){
      const order = Array.from({length:names.length}, (_,i)=>i);
      shuffle(order);
      st = { order, pos: 0, hash: h, total: names.length };
      saveState(country, gender, st);
    }

    const idx = st.order[st.pos];
    st.pos += 1;
    saveState(country, gender, st);

    const picked = names[idx] || "‚Äî";
    $("nameBox").textContent = picked;

    const left = st.order.length - st.pos;
    setStatus(`Generated: ${country} (${gender}) ‚Ä¢ Remaining (no-repeat): ${left}/${st.order.length}`, true);
  }catch(e){
    setStatus("Error: " + (e.message || e), false);
  }finally{
    $("genBtn").disabled = false;
  }
}

/* ========= Init ========= */
async function init(){
  $("nameBox").textContent = "Loading‚Ä¶";
  setStatus("Preparing local cache‚Ä¶", true);

  try{
    startNoticeListener();

    // Sync only if needed (Option A)
    await syncIfNeeded({ force:false });

    const countries = await loadCountriesLocal();
    const sel = $("countrySelect");
    sel.innerHTML = "";

    if(!countries.length){
      sel.innerHTML = `<option value="">No countries yet</option>`;
      $("nameBox").textContent = "No data";
      setStatus("No countries found. Add from admin panel.", false);
      return;
    }

    countries.forEach(c=>{
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      sel.appendChild(opt);
    });

    $("nameBox").textContent = "Tap Generate";
    setStatus("Ready ‚úÖ Select country & gender.", true);
  }catch(e){
    $("countrySelect").innerHTML = `<option value="">Error</option>`;
    $("nameBox").textContent = "Error";
    setStatus("Failed to load data: " + (e.message || e), false);
  }
}

/* ========= Events ========= */
$("genBtn").addEventListener("click", generate);

$("nameBox").addEventListener("click", async ()=>{
  const txt = $("nameBox").textContent.trim();
  if(!txt || ["Tap Generate","Loading‚Ä¶","No data","No names found","Error"].includes(txt)) return;

  const ok = await copyText(txt);
  toast(ok ? "Copied ‚úÖ" : "Copy failed ‚ùå");
});

$("resetBtn").addEventListener("click", ()=>{
  const country = $("countrySelect").value;
  const gender = $("genderSelect").value;
  if(!country) return;

  resetState(country, gender);
  toast("Reset done ‚úÖ");
  setStatus(`Reset: ${country} (${gender}) ‚Äî next generate will reshuffle.`, true);
});

$("refreshBtn").addEventListener("click", async ()=>{
  try{
    $("genBtn").disabled = true;
    $("countrySelect").innerHTML = `<option value="">Loading...</option>`;
    $("nameBox").textContent = "Loading‚Ä¶";

    // Force full resync (Option A)
    cache.countries = [];
    cache.namesByCG = {};
    await syncIfNeeded({ force:true });

    await init();
  }catch(e){
    setStatus("Refresh failed: " + (e.message || e), false);
  }finally{
    $("genBtn").disabled = false;
  }
});

/* Start */
init();
</script>
</body>
</html>






